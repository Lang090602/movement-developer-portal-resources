#+TITLE: Basic Collection Resource

* Table of Content :TOC:
- [[#contract][Contract]]
  - [[#hello-world-contract][Hello world Contract]]
  - [[#integer][Integer]]
  - [[#boolean][Boolean]]

* Contract
** Hello world Contract
#+begin_src move
module movement::hello_world {
    struct MoveResource has key {
        value: u64
    }

    fun init_module(caller: &signer) {
        move_to(caller, MoveResource {
            value: 10
        });
    }
}
#+end_src

** Integer
*** Summary
- Move supports six unsigned integer types: =u8=, =u16=, =u32=, =u64=, =u128=, and =u256=.
- Direct mathematical operations between different integer types are not allowed.
- Type casting is necessary when performing operations with different integer types.
- It's recommended to cast smaller types to larger types to avoid overflow risks.
- The module demonstrates adding a =u8= and a =u64= by converting =u8= to =u64=.
- A test function verifies the addition operation.
- The code can be tested using the Move test command.

*** Overview
Move supports six unsigned integer types: =u8=, =u16=, =u32=, =u64=, =u128=, and =u256=. Values of these types range from 0 to a maximum that depends on the size of the type.
Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type

#+begin_src move
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
#+end_src

To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.

#+begin_src move
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
#+end_src

#+begin_quote
One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
#+end_quote

*** Example Code
This code defines a module in Move language that includes a function =plus_two_types=, which adds a =u8= and a =u64= after converting the =u8= to =u64=. The module also contains a test function =test_plus_two_types= that verifies the addition operation.

#+begin_src move
module movement::integer_module {
    use std::debug::print;

    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }

    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
}
#+end_src

- Execute test in the terminal
#+begin_src sh
aptos move test --package-dir ./sources/basic --skip-attribute-checks
#+end_src

#+begin_src move
[debug] 105
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::integer_module::test_plus_two_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
#+end_src

** Boolean
*** Summary
- Boolean is a primitive data type in Move representing =true= or =false= values
- Essential for implementing logic and controlling program flow
- Declared using the bool type (e.g., `let a: bool = true`)
- Used in conditional statements and loops
- Can be printed and tested in Move modules
- Fundamental for effective programming and robust application development in Move

*** Overview
Boolean types in Move are a primitive data type that represent two possible values: =true= and =false=. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.

**** Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.

**** Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
#+begin_src move
let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false
#+end_src

*** Example Code
Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
#+begin_src move
module movement::boolean_type {
    use std::debug::print;

    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }

    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}
#+end_src

- Run test on terminal
#+begin_src sh :results output :session share :async true
aptos move test --package-dir ./sources/basic --skip-attribute-checks
#+end_src

#+begin_src sh
Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
#+end_src

*** Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.
