#+TITLE: Basic Collection Resource

* Table of Content :TOC:
- [[#contents][Contents]]
  - [[#hello-world-contract][Hello world Contract]]
  - [[#integer][Integer]]
  - [[#boolean][Boolean]]
  - [[#address--signer][Address & Signer]]

* Contents
** Hello world Contract
#+begin_src move
module movement::hello_world {
    struct MoveResource has key {
        value: u64
    }

    fun init_module(caller: &signer) {
        move_to(caller, MoveResource {
            value: 10
        });
    }
}
#+end_src

** Integer
*** Summary
- Move supports six unsigned integer types: =u8=, =u16=, =u32=, =u64=, =u128=, and =u256=.
- Direct mathematical operations between different integer types are not allowed.
- Type casting is necessary when performing operations with different integer types.
- It's recommended to cast smaller types to larger types to avoid overflow risks.
- The module demonstrates adding a =u8= and a =u64= by converting =u8= to =u64=.
- A test function verifies the addition operation.
- The code can be tested using the Move test command.

*** Overview
Move supports six unsigned integer types: =u8=, =u16=, =u32=, =u64=, =u128=, and =u256=. Values of these types range from 0 to a maximum that depends on the size of the type.
Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type

#+begin_src move
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
#+end_src

To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.

#+begin_src move
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
#+end_src

#+begin_quote
One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
#+end_quote

*** Example Code
This code defines a module in Move language that includes a function =plus_two_types=, which adds a =u8= and a =u64= after converting the =u8= to =u64=. The module also contains a test function =test_plus_two_types= that verifies the addition operation.

#+begin_src move
module movement::integer_module {
    use std::debug::print;

    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }

    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
}
#+end_src

- Execute test in the terminal
#+begin_src sh
aptos move test --package-dir ./sources/basic --skip-attribute-checks
#+end_src

#+begin_src move
[debug] 105
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::integer_module::test_plus_two_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
#+end_src

** Boolean
*** Summary
- Boolean is a primitive data type in Move representing =true= or =false= values
- Essential for implementing logic and controlling program flow
- Declared using the bool type (e.g., `let a: bool = true`)
- Used in conditional statements and loops
- Can be printed and tested in Move modules
- Fundamental for effective programming and robust application development in Move

*** Overview
Boolean types in Move are a primitive data type that represent two possible values: =true= and =false=. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.

**** Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.

**** Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
#+begin_src move
let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false
#+end_src

*** Example Code
Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
#+begin_src move
module movement::boolean_type {
    use std::debug::print;

    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }

    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}
#+end_src

- Run test on terminal
#+begin_src sh :results output :session share :async true
aptos move test --package-dir ./sources/basic --skip-attribute-checks
#+end_src

#+begin_src sh
Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
#+end_src

*** Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.

** Address & Signer
*** Address
**** Summary
- Address is a 256-bit identifier representing locations in global storage in Move.
- Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
- Address syntax includes named and numerical forms, with @ prefix in expression contexts.
- Signer represents authority over blockchain resources and is used for transaction execution.
- Signer values are automatically generated by the Move VM and cannot be created through literals.
- The `std::signer` module provides utility functions for working with signers.
- Addresses are primarily used for global storage operations, while signers are used for transaction authorization.

**** Address Overview
Address is an integrated data type in Move used to represent locations (sometimes referred to as accounts) in global storage. An address value is a `256-bit` (`32-byte`) identifier. At a specific address, two things can be stored: a `Module` and a `Resource`.

Although an address is a `256-bit` integer, Move addresses are designed to be intentionally opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot be altered. While there may be interesting programs utilizing such features (for example, pointer operators in C serve a similar role), Move does not allow such dynamic behavior as it is designed from the ground up to support static verification.

You can use address values at runtime (address-type values) to access resources at that address. You cannot access modules at runtime through address values.

**** Address and Syntax:
Addresses have two forms: `named` or `numerical`. The syntax of named addresses follows the same rules as any identifier name in Move. The syntax of numerical addresses is not limited to hexadecimal values, and any valid u256 numeric value can be used as an address value; for example, `40`, `0xCAFE`, and `2024` are all valid numeric address literals.

To distinguish when an address is being used in the context of an expression or not, the syntax for using an address varies depending on the context in which it is used:

- When an address is used as an expression, it must be prefixed by the character @, for example: =@<numerical_value>= or =@<named_address_identifier>=.
- Outside of expression contexts, an address can be written without the prefix @, for example: =<numerical_value>= or =<named_address_identifier>=.

**** Declaring Address Variables
#+begin_src move
let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example
#+end_src

**** Primary purpose
- The primary purpose of addresses is to interact with global storage operations.
- Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
- The only global storage operation that does not use an address is move_to, which uses a signer instead.

*** Signer
**** Signer Overview
Signer is a data type that represents the authority and control over a resource or asset on the blockchain. The signer data type is used to designate which account or entity is responsible for executing a specific transaction or operation on the blockchain.

You can think of its native implementation as follows:

`struct signer has drop { a: address }`

**** Declaring Signer Variables
Signer values are special because they cannot be created through literals or instruction-only constructs that can be generated by the =MoveVM=. Before the VM executes a script with parameters of the signer type, it will automatically generate =signer= values and pass them into the code:

#+begin_src move
module movement::address_and_signer {
    use std::signer;

    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }

    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
#+end_src

=signer= Operations: The package =std::signer= in the standard library module provides 2 utility functions for signer:

- =signer::address_of(&signer)=: address - Returns the address wrapped by &signer.
- =signer::borrow_address(&signer)=: &address - Returns a reference to the address wrapped by =&signer=.

#+begin_src move
module movement::address_and_signer {
    use std::signer;
    use std::debug::print;

    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }

    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }

    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}
#+end_src

- Running test
#+begin_src sh
aptos move test --package-dir ./sources/basic --skip-attribute-checks
#+end_src

#+begin_src sh
Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
#+end_src
