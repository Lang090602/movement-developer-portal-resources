#+TITLE: Basic Collection Resource

* Table of Content :TOC:
  - [[#contract][Contract]]
  - [[#integer][Integer]]

** Contract
*** Hello world
#+begin_src move
module movement::hello_world {
    struct MoveResource has key {
        value: u64
    }

    fun init_module(caller: &signer) {
        move_to(caller, MoveResource {
            value: 10
        });
    }
}
#+end_src

** Integer
*** Summary
- Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
- Direct mathematical operations between different integer types are not allowed.
- Type casting is necessary when performing operations with different integer types.
- It's recommended to cast smaller types to larger types to avoid overflow risks.
- The module demonstrates adding a u8 and a u64 by converting u8 to u64.
- A test function verifies the addition operation.
- The code can be tested using the Move test command.

*** Overview
Move supports six unsigned integer types: `u8`, `u16`, `u32`, `u64`, `u128`, and `u256`. Values of these types range from 0 to a maximum that depends on the size of the type.

Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type

#+begin_src move
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
#+end_src

To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.

#+begin_src move
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
#+end_src

> One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.

*** Code Start
This code defines a module in Move language that includes a function plus_two_types, which adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function test_plus_two_types that verifies the addition operation.

#+begin_src move
module movement::integer_module {
    use std::debug::print;

    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }

    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
}
#+end_src

> Execute test in the terminal


#+begin_src sh
aptos move test
#+end_src

#+begin_src json
[debug] 105
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::integer_module::test_plus_two_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
#+end_src
